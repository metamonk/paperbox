# W2.D12 Integration Testing Plan

## Overview
Comprehensive integration testing of all Week 2 features (D1-D11) in the live application to validate complete feature stack functionality, multi-user collaboration, and performance targets.

## Test Objectives
1. **Feature Integration**: Verify all W2.D1-D11 features work together seamlessly
2. **Multi-User Collaboration**: Test viewport independence and real-time sync with 2+ users
3. **Performance Validation**: Benchmark with 500+ objects and measure response times
4. **Error Recovery**: Validate graceful degradation and error handling
5. **Production Readiness**: Confirm application meets all Phase 2 success criteria

## Features Under Test (W2.D1-D11)

### W2.D1-D4: Fabric.js Migration & Zustand Integration ✅
- **Fabric.js Canvas**: Rectangle, circle, ellipse, text rendering
- **FabricCanvasManager**: Object creation, selection, modification, deletion
- **Zustand Stores**: canvasSlice, cursorSlice, userSlice state management
- **Real-time Sync**: Supabase postgres_changes subscription (INSERT/UPDATE/DELETE)

### W2.D5: Bidirectional Sync Layer ✅
- **CanvasSyncManager**: Fabric ↔ Zustand bidirectional sync
- **Loop Prevention**: `_isSyncingFromCanvas` and `_isSyncingFromStore` flags
- **Change Detection**: Optimized updates with `hasObjectChanged()`
- **Sync Pipeline**: Fabric.js ↔ CanvasSyncManager ↔ Zustand ↔ SyncManager ↔ Supabase

### W2.D6-D7: Infinite Canvas & Viewport ✅
- **Viewport State**: zoom, panX, panY in Zustand store
- **Mousewheel Zoom**: 0.01-20x zoom range, cursor-centered
- **Spacebar Pan**: Drag panning with grab/grabbing cursors
- **Viewport Persistence**: localStorage (instant) + PostgreSQL (5s debounce)
- **RAF Throttling**: 60fps viewport sync optimization
- **Canvas Boundaries**: ±50,000 pixels from origin

### W2.D8: Navigation Shortcuts ✅
- **Cmd+0**: Reset viewport to [1,0,0,1,0,0]
- **Cmd+1**: Zoom to 100% (1.0x)
- **Cmd+2**: Zoom to 200% (2.0x)
- **Cmd+9**: Zoom to selection (collective bounds with 20% padding)
- **Canvas Background**: #f5f5f5 light gray (Figma-style)
- **Pixel Grid**: Pan-aware grid rendering

### W2.D9: Component Architecture ✅
- **CanvasLoadingOverlay**: Extracted component (52 lines)
- **useShapeCreation**: Custom hook for shape creation (106 lines)
- **useSidebarState**: Sidebar state management hook (77 lines)
- **CursorOverlay**: Optimized with React.memo

### W2.D10: Code Splitting ✅
- **React.lazy()**: Route-level code splitting (Login, Signup, CanvasPage)
- **Suspense**: Loading boundaries with RouteLoadingFallback
- **Bundle Optimization**: On-demand chunk loading

### W2.D11: Batch Operations & State Persistence ✅
- **batchAddObjects()**: Optimized multi-object addition with single render
- **batchRemoveObjects()**: Optimized multi-object removal
- **saveState()**: Serialize canvas to JSON (objects + viewport + config)
- **loadState()**: Restore canvas from saved state

## Test Environment Setup

### Prerequisites
```bash
# Development server running
pnpm dev → http://localhost:5173

# Test accounts (2+ users for multi-user testing)
User 1: test1@example.com
User 2: test2@example.com
```

### Browser Configuration
- **Primary**: Chrome DevTools (Performance tab open)
- **Secondary**: Firefox/Safari (cross-browser validation)
- **Network**: Throttle to Fast 3G for real-world testing
- **CPU**: 4x slowdown for performance stress testing

## Integration Test Scenarios

### Scenario 1: Canvas Initialization & Basic Rendering
**Objective**: Verify Fabric.js canvas initializes correctly with Zustand state

**Steps**:
1. Navigate to `/canvas` (authenticated)
2. Verify canvas renders with #f5f5f5 background
3. Verify pixel grid displays at default zoom
4. Check Zustand store initialization (React DevTools)
5. Verify cursor overlay renders

**Expected Results**:
- ✅ Canvas visible with correct background color
- ✅ Pixel grid rendered and aligned
- ✅ Zustand stores initialized with default state
- ✅ No console errors
- ✅ Loading overlay dismisses after initialization

**Actual Results**: [To be filled during testing]

---

### Scenario 2: Shape Creation & Real-time Sync
**Objective**: Validate shape creation, Zustand sync, and Supabase persistence

**Steps**:
1. Click "Rectangle" tool in sidebar
2. Draw rectangle on canvas (drag interaction)
3. Verify rectangle appears in Fabric.js canvas
4. Check Zustand store for object entry (React DevTools)
5. Check PostgreSQL for object record (Supabase dashboard)
6. Open second browser/incognito with User 2
7. Verify rectangle appears for User 2 (real-time sync)

**Expected Results**:
- ✅ Rectangle renders immediately after creation
- ✅ Object added to `canvasSlice.objects` array
- ✅ Database INSERT within 100ms
- ✅ User 2 sees rectangle within 200ms (real-time sync)
- ✅ No duplicate objects or sync loops

**Actual Results**: [To be filled during testing]

---

### Scenario 3: Bidirectional Sync (Fabric ↔ Zustand)
**Objective**: Test CanvasSyncManager bidirectional sync without loops

**Steps**:
1. Create 3 objects (rectangle, circle, text)
2. Move object in Fabric.js (drag with mouse)
3. Verify Zustand store updates with new position
4. Update object via Zustand action (developer console):
   ```javascript
   window.useCanvasStore.getState().updateObject(id, { fill: 'red' })
   ```
5. Verify Fabric.js object updates visually
6. Check console for sync loop warnings

**Expected Results**:
- ✅ Fabric → Zustand: Position updates reflected in store
- ✅ Zustand → Fabric: Color change renders in canvas
- ✅ No sync loop warnings in console
- ✅ `_isSyncingFromCanvas` and `_isSyncingFromStore` flags work correctly

**Actual Results**: [To be filled during testing]

---

### Scenario 4: Viewport Pan & Zoom
**Objective**: Validate mousewheel zoom and spacebar panning

**Steps**:
1. Create 5 objects spread across canvas
2. Test mousewheel zoom:
   - Scroll up → zoom in (cursor-centered)
   - Scroll down → zoom out (cursor-centered)
   - Verify zoom clamped to 0.01-20 range
3. Test spacebar pan:
   - Hold spacebar → cursor changes to grab
   - Drag canvas → cursor changes to grabbing
   - Release spacebar → cursor reverts
4. Verify viewport state in Zustand store
5. Refresh page → verify viewport restored (localStorage)

**Expected Results**:
- ✅ Zoom centered on cursor position
- ✅ Zoom clamped to 0.01-20 range
- ✅ Spacebar pan updates viewport smoothly
- ✅ Cursor states change correctly (grab/grabbing)
- ✅ Zustand viewport state updates on mouse:up
- ✅ Viewport restored after refresh (localStorage persistence)

**Actual Results**: [To be filled during testing]

---

### Scenario 5: Navigation Shortcuts
**Objective**: Test keyboard shortcuts for viewport navigation

**Steps**:
1. Create 10 objects at various positions
2. Zoom to 5x and pan away from origin
3. Test Cmd+0 (reset viewport) → viewport should reset to [1,0,0,1,0,0]
4. Pan away, test Cmd+1 (zoom 100%) → zoom should be 1.0
5. Test Cmd+2 (zoom 200%) → zoom should be 2.0
6. Select 3 objects, test Cmd+9 (zoom to selection)
   - Should calculate collective bounds
   - Should zoom with 20% padding
   - Should center on selection

**Expected Results**:
- ✅ Cmd+0: Viewport resets correctly
- ✅ Cmd+1: Zoom set to 100%
- ✅ Cmd+2: Zoom set to 200%
- ✅ Cmd+9: Selection fits in viewport with padding
- ✅ All shortcuts execute <50ms (performance target)

**Actual Results**: [To be filled during testing]

---

### Scenario 6: Viewport Persistence (Cross-Device)
**Objective**: Validate PostgreSQL viewport persistence and cross-device sync

**Steps**:
1. Set viewport to specific state (zoom: 2.5, pan: {x: 1000, y: -500})
2. Wait 6 seconds (debounce delay)
3. Check `user_canvas_viewports` table in Supabase
4. Open new browser/device with same user
5. Verify viewport restored from database

**Expected Results**:
- ✅ Viewport saved to localStorage immediately
- ✅ Viewport saved to PostgreSQL after 5s debounce
- ✅ Cross-device viewport restored correctly
- ✅ Database query returns user-specific viewport

**Actual Results**: [To be filled during testing]

---

### Scenario 7: Multi-User Collaboration (Viewport Independence)
**Objective**: Test multi-user editing with independent viewports

**Setup**:
- User 1: Chrome (localhost:5173)
- User 2: Firefox/Incognito (localhost:5173)

**Steps**:
1. User 1: Create rectangle at position (100, 100)
2. User 2: Verify rectangle appears (real-time sync)
3. User 1: Zoom to 5x, pan to (2000, -1000)
4. User 2: Verify zoom/pan remains independent (not affected by User 1)
5. User 2: Move User 1's rectangle
6. User 1: Verify rectangle moves in User 1's viewport
7. Both users: Create objects simultaneously
8. Verify both objects appear for both users (no conflicts)

**Expected Results**:
- ✅ Objects sync in real-time (<200ms)
- ✅ Viewports remain independent per user
- ✅ Concurrent object creation handled without conflicts
- ✅ Object modifications sync correctly
- ✅ No sync loops or duplicate objects

**Actual Results**: [To be filled during testing]

---

### Scenario 8: Batch Operations Performance
**Objective**: Test batch operations with large object counts

**Steps**:
1. Clear canvas (delete all objects)
2. Prepare 100 CanvasObject definitions in console:
   ```javascript
   const objects = Array.from({ length: 100 }, (_, i) => ({
     id: crypto.randomUUID(),
     type: 'rect',
     x: (i % 10) * 100,
     y: Math.floor(i / 10) * 100,
     width: 80,
     height: 80,
     fill: `hsl(${i * 3.6}, 70%, 50%)`
   }));
   ```
3. Test batchAddObjects():
   ```javascript
   const manager = window.fabricManagerInstance;
   console.time('batchAdd');
   manager.batchAddObjects(objects);
   console.timeEnd('batchAdd');
   ```
4. Count render calls (should be 1, not 100)
5. Test batchRemoveObjects():
   ```javascript
   const ids = objects.map(obj => obj.id);
   console.time('batchRemove');
   manager.batchRemoveObjects(ids);
   console.timeEnd('batchRemove');
   ```

**Expected Results**:
- ✅ batchAddObjects: Single render call for 100 objects
- ✅ batchAddObjects: <50ms for 100 objects
- ✅ batchRemoveObjects: Single render call
- ✅ batchRemoveObjects: <30ms for 100 objects
- ✅ No individual render calls during batch operations

**Actual Results**: [To be filled during testing]

---

### Scenario 9: State Persistence (Save/Load)
**Objective**: Validate saveState() and loadState() for canvas snapshots

**Steps**:
1. Create complex canvas state:
   - 10 objects of different types
   - Custom viewport (zoom: 1.5, pan: {x: 500, y: -300})
   - Canvas background color: #e0e0e0
2. Save state:
   ```javascript
   const manager = window.fabricManagerInstance;
   const state = manager.saveState();
   console.log('Saved state:', state);
   ```
3. Verify saved state includes:
   - objects array (10 CanvasObjects)
   - backgroundColor, width, height
   - zoom, panX, panY
4. Modify canvas (add/remove objects, change viewport)
5. Load state:
   ```javascript
   manager.loadState(state);
   ```
6. Verify canvas restored to saved state

**Expected Results**:
- ✅ saveState() captures complete canvas state
- ✅ saveState() serializes objects to CanvasObject format
- ✅ saveState() includes viewport transform
- ✅ loadState() clears canvas before restoration
- ✅ loadState() restores all objects and viewport
- ✅ loadState() <100ms for 10 objects

**Actual Results**: [To be filled during testing]

---

### Scenario 10: Performance Benchmark (500+ Objects)
**Objective**: Validate performance targets with large object count

**Setup**:
- Chrome DevTools Performance tab recording
- CPU throttling: 4x slowdown
- Network: Fast 3G

**Steps**:
1. Create 500 objects using batch operation:
   ```javascript
   const objects = Array.from({ length: 500 }, (_, i) => ({
     id: crypto.randomUUID(),
     type: i % 4 === 0 ? 'circle' : 'rect',
     x: (i % 25) * 100,
     y: Math.floor(i / 25) * 100,
     width: i % 4 === 0 ? 50 : 80,
     height: i % 4 === 0 ? 50 : 80,
     fill: `hsl(${i * 0.72}, 60%, 50%)`
   }));

   const manager = window.fabricManagerInstance;
   console.time('create500');
   manager.batchAddObjects(objects);
   console.timeEnd('create500');
   ```
2. Test viewport operations:
   - Mousewheel zoom in/out (10 operations)
   - Spacebar pan (5 drag operations)
   - Navigation shortcuts (Cmd+0, Cmd+1, Cmd+2)
3. Test selection:
   - Click individual objects (10 objects)
   - Select multiple objects (Cmd+click 5 objects)
4. Test object modification:
   - Drag object to new position (5 objects)
   - Resize object (3 objects)
5. Record Performance metrics:
   - FPS during zoom/pan
   - Time for selection operations
   - Time for object modifications
   - Memory usage (heap snapshot)

**Expected Results**:
- ✅ Create 500 objects: <500ms
- ✅ Zoom operations: >30 FPS, <50ms each
- ✅ Pan operations: >30 FPS
- ✅ Selection: <100ms per object
- ✅ Object modification: <100ms per operation
- ✅ Memory usage: <150MB total heap
- ✅ No frame drops during interactions
- ✅ Viewport sync: <5ms average

**Actual Results**: [To be filled during testing]

---

### Scenario 11: Error Recovery & Edge Cases
**Objective**: Validate graceful error handling and edge cases

**Steps**:
1. **Network Disconnection**:
   - Disconnect network (Chrome DevTools → Offline)
   - Create objects (should work optimistically)
   - Reconnect network
   - Verify objects sync to database

2. **Invalid Object Data**:
   - Attempt to create object with invalid data
   - Verify error handling (no canvas crash)

3. **Concurrent Modifications**:
   - User 1 & User 2 modify same object simultaneously
   - Verify conflict resolution (last-write-wins)

4. **Extreme Viewport Values**:
   - Zoom to max (20x)
   - Zoom to min (0.01x)
   - Pan to boundaries (±50,000)
   - Verify viewport clamping works

5. **Rapid Interactions**:
   - Spam mousewheel zoom (50 scroll events)
   - Rapid spacebar pan (drag quickly)
   - Verify RAF throttling prevents overload

**Expected Results**:
- ✅ Offline mode: Optimistic updates work
- ✅ Invalid data: Graceful error messages
- ✅ Conflicts: Last-write-wins resolution
- ✅ Extreme viewport: Proper clamping
- ✅ Rapid interactions: No performance degradation
- ✅ No console errors or crashes

**Actual Results**: [To be filled during testing]

---

## Performance Benchmarks

### Target Metrics
| Metric | Target | Actual |
|--------|--------|--------|
| Object creation (single) | <50ms | |
| Object creation (batch 100) | <100ms | |
| Object creation (batch 500) | <500ms | |
| Zoom operation | <50ms | |
| Pan operation (FPS) | >30 FPS | |
| Selection (single) | <100ms | |
| Real-time sync latency | <200ms | |
| Viewport sync (RAF) | <5ms | |
| Navigation shortcuts | <50ms | |
| Memory usage (500 objects) | <150MB | |

### Performance Profiling
- **Chrome DevTools Performance**: Record full interaction session
- **React DevTools Profiler**: Measure component render times
- **Network Tab**: Monitor Supabase real-time message sizes
- **Memory Profiler**: Check for memory leaks during extended use

## Test Execution Checklist

### Pre-Testing
- [ ] Development server running (pnpm dev)
- [ ] Supabase project accessible
- [ ] Test accounts created (2+ users)
- [ ] Browser DevTools configured
- [ ] Baseline performance profile captured

### During Testing
- [ ] Execute all 11 scenarios
- [ ] Record actual results for each scenario
- [ ] Capture screenshots/videos of critical interactions
- [ ] Note any console errors or warnings
- [ ] Monitor performance metrics continuously

### Post-Testing
- [ ] Analyze performance profiling data
- [ ] Compare actual vs target metrics
- [ ] Document any bugs or issues found
- [ ] Create GitHub issues for failures
- [ ] Update MASTER_TASK_LIST.md with results
- [ ] Generate W2.D12 summary document

## Known Limitations

From W2.D11 summary, 66 test failures remain (test infrastructure issues):
- FabricCanvasManager mocks missing properties
- Event listener mocks not triggering
- Viewport persistence initialization order
- useCanvas hooks authentication/spy configuration

**Note**: These are test infrastructure issues, not production bugs. Integration testing will validate production code paths.

## Success Criteria

### Must Pass (Critical)
- ✅ All 11 integration scenarios pass
- ✅ Multi-user collaboration works with viewport independence
- ✅ Performance benchmarks meet targets (500 objects, <100ms sync)
- ✅ No console errors during normal operation
- ✅ Graceful error handling for edge cases

### Should Pass (Important)
- ✅ Performance profiling shows no bottlenecks
- ✅ Memory usage stays within budget
- ✅ Cross-browser compatibility (Chrome, Firefox, Safari)
- ✅ Network resilience (offline → online recovery)

### Nice to Have
- ✅ Performance exceeds targets by 20%+
- ✅ Zero accessibility warnings
- ✅ Lighthouse score >90

## Next Steps After W2.D12

1. **W2.D13.1**: Milestone 1 Validation (full test suite with `/sc:test`)
2. **W2.D13.2**: Week 2 Summary & Retrospective
3. **Bugs/Issues**: Create GitHub issues for any failures
4. **Documentation**: Update Serena memory with integration patterns
5. **Planning**: Prepare for Week 3 (Selection & Transform Engines)
